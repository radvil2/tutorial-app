const app = require("express")();
const http = require("http").Server(app);
const io = require("socket.io")(http);

const port = 8080;

/**
  Our next line would be in-memory store fo documents.
  Disclaimer: you probably shouldn't use this in production mode, instead use the real database for this.
 */

const documents = {};

// Now let's define what we want our socket server to actually do.

// .on() is an event listener. The first parameter is the name of the event, and the 2nd one is usually a callback executed when the event fires, with the event payload.

io.on("connection", (socket) => {
  // First example we see when the client connects to a socket server (connection is a reserve event type in Socket.io).

  // We got a socket variable to pass to our callback, to initiate communication to either that one socket, or to multiple sockets(i.e. broadcasting).

  let previousId;
  const safeJoin = (currentId) => {
    socket.leave(previousId);
    socket.join(currentId);
    previousId = currentId;
  };

  // I've setup a local function (safejoin) that takes care of joining and leaving "rooms". In this case, when a client joined a room, they're editing the particular doc. So, if multiple clients are in the same room, they're all editing the same document.

  // Technically, a socket can be in multiple rooms, but we don't want to let one client to be able to edit multiple documents at the same time, so, if they switch documents, we need to leave the previous room and join a new room. This little function takes care of that.

  // There are three types that our socket is listening for from the client. getDoc, addDoc, and editDoc.

  // And two event types that are emitted by our socket to the client. document, and documents.

  socket.on("getDoc", (docId) => {
    safeJoin(docId);
    socket.emit("document", documents[docId]);
  });

  // When the client emits the getDoc event, the socket is gonna take the payload (in our case just an id), then join a room with that doc.id, and emit the stored document back to the initiating client only.

  // That's where socket.emit('document', ...) comes into play.

  socket.on("addDoc", (doc) => {
    documents[doc.id] = doc;
    safeJoin(doc.id);
    io.emit("documents", Object.keys(documents));
    socket.emit("document", doc);
  });

  // With the addDoc event, the payload is the document object, which at the moment consist of an id generated by the client.

  // We tell our socket to join the room with that id, so that any future edits can be broadcasted to anyone in the same room.

  // Next we want everyone connected to know that there is a new doc to work with, so we braodcast to all clients with the io.emit('documents', ...) function.

  // You'll notice this same emit also happens whenever a new connection is made.

  // Note that diferrent between socket.emit() and io.emit() - the socket.emit() is for emiting back to only initiating client, the io.emmit() is for emitting to everyone connected to our server.

  socket.on("editDoc", (doc) => {
    documents[doc.id] = doc;
    socket.to(doc.id).emit("document", doc);
  });

  // Finally with editDoc event, the payload will be the whole documents at its state after any keystroke.

  // We replace the existing documents. We'll replace the existing document in the database, and then broadcast a new document to only the clients that are currently viewing that document.

  // We do this by calling socket.to(doc.id).emit("document", doc), which emits all sockets in the particular room

  io.emit("documents", Object.keys(documents));
});

// After the socket functions are all setup, pick a port and listen on it.

const startApp = async () => {
  try {
    await http.listen(port);

    console.log(`Socket server started. \nListening on port ${port}`);
  } catch (error) {
    console.log(error);
  }
};

startApp();

// We now have a fully-functionin socket server for document collaboration.
// Run $ node app.js.

// check alligator.io for the frontend implementation.